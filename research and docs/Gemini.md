Project Mugen-Kai: Architectural Blueprint for an Infinite-Scaling, Data-Driven Roguelike1. Executive Summary and Market Positioning1.1 The Stagnation of the "Bullet Heaven" GenreThe "survivor-like" or "bullet heaven" genre, popularized by Vampire Survivors, has rapidly saturated the market. While the core loop—automatic attacks, horde management, and incremental upgrades—remains chemically addictive, the technical and mechanical ceilings of current titles are evident. Most engines, typically built on Unity or Godot, struggle to maintain performance past a certain entity density, forcing developers to cap enemy counts or rely on "object pooling" tricks that limit simulation complexity. Furthermore, the "power fantasy" is often strictly numerical: damage numbers go up, but the nature of the interaction remains static.Project Mugen-Kai aims to shatter these ceilings. It is not merely a game but a high-performance simulation engine designed to handle theoretical infinite scaling. By leveraging the Rust programming language and a strict Data-Oriented Design (DOD) philosophy via the Bevy Engine, Mugen-Kai will support 100,000+ active entities, arbitrary-precision mathematical scaling (exceeding $10^{1000}$), and complex, rule-based interactions inspired by sophisticated anime power systems like Hunter x Hunter.11.2 Core Pillars of InnovationThe project distinguishes itself through four distinct "Million-Dollar" mechanical pillars, each addressing a gap in the current market:The "Cryptid" Mathematical Engine: Inspired by the Balatro Cryptid mod, players do not just increase stats; they manipulate the game's underlying formulas. This allows for "broken" builds where linear damage scaling can be converted into exponential or recursive growth curves.4The "Nen" Interaction System: Moving beyond simple collision damage, abilities interact via a rigid rule set derived from Hunter x Hunter. A "Bungee Gum" ability is not just a slow effect; it is a physics constraint with elastic properties, simulated efficiently in the ECS.6The Predatory Economy: To introduce high-stakes tension, the game creates a "debt trap" meta-game. Players finance their runs through high-interest loans from a "Loan Shark" faction, creating a psychological pressure cooker where financial ruin is as dangerous as physical death.8The "Director" Pacing Engine: Utilizing an advanced version of the Left 4 Dead Director AI, the game monitors player stress metrics—inputs per second, health flux, and resource starvation—to dynamically pace the horde, ensuring the player remains in a flow state rather than being overwhelmed by random noise.10This report serves as the comprehensive technical and design document for Project Mugen-Kai. It details the architectural decisions required to achieve this vision, from the low-level memory management in Rust to the high-level economic theory driving the gameplay loop.2. Technical Architecture: The Rust Foundation2.1 The Necessity of Rust and Data-Oriented DesignThe primary technical constraint of Project Mugen-Kai is the requirement to handle "infinite scaling without lag." In a traditional Object-Oriented Programming (OOP) context (e.g., C# in Unity), each enemy unit is an object allocated on the heap. As the entity count rises to 100,000, the CPU spends the majority of its cycles chasing pointers across fragmented memory (cache misses) rather than processing game logic. The Terraria backend rewrite demonstrated that moving from managed languages to Rust can reduce latency by 60% and halve CPU usage due to memory safety and strict control over system resources.1To solve the scale problem, Mugen-Kai utilizes the Bevy Engine, which is built around an Entity Component System (ECS). In this architecture, "enemies" are not objects. They are simply unique Integer IDs (Entities). Their data—Health, Position, Velocity—are stored in contiguous arrays called Components. This layout is critical for modern CPU performance. When the "Movement System" runs, it iterates over the "Position" and "Velocity" arrays. Because these arrays are contiguous in memory, the CPU's pre-fetcher can load them into the L1 and L2 caches extremely efficiently, minimizing the time the processor sits idle waiting for RAM access.22.2 ECS Archetypes and Table StorageBevy’s specific implementation of ECS uses Archetypes, which groups entities that have the exact same set of components into tables. This allows for extremely fast iteration. However, a "roguelike" often involves adding temporary status effects (e.g., "Burning," "Frozen," "Stunned"), which in a naive ECS implementation would cause "Archetype Fragmentation." If an entity gains a "Burning" component, it must be moved from the [Health, Position] table to the `` table. This move involves copying memory, which is expensive if done for 10,000 entities simultaneously.12To mitigate this, Mugen-Kai will employ a hybrid storage strategy. Core components (Position, Health, Sprite) will use Table Storage for maximum iteration speed. Volatile tags (Burning, Stunned) will use Sparse Set Storage. Sparse sets allow components to be added or removed without moving the entity's core data in memory, preventing the "fragmentation cost" while maintaining $O(1)$ lookup times. This distinction is vital for maintaining 60 FPS during chaotic combat where status effects are applied rapidly.132.3 Parallelism and ThreadingRust’s ownership model allows for fearless concurrency. The Bevy scheduler automatically parallelizes systems that do not conflict. For example, the MovementSystem (which writes to Position) and the AnimationSystem (which reads Position and writes to Sprite) can potentially run in parallel if structured correctly. For the massive swarm AI, we will utilize Task Pools (specifically bevy::tasks) to shard the AI calculations across all available CPU cores. If the player has a 16-core processor, the 100,000 enemies are divided into 16 batches of 6,250, processed simultaneously.22.4 GPU Instancing for RenderingEven if the CPU can update 100,000 entities, the GPU must render them. Traditional "Draw Call" approaches (one draw call per sprite) bottleneck at around 10,000 sprites. Mugen-Kai will implement GPU Instancing via Bevy’s wgpu backend. We upload a single mesh (the quad) and a single material texture to the GPU. Then, we upload a massive "Instance Buffer" containing the transform matrices and color tints for all 100,000 entities. The GPU renders all instances in a single draw call. Benchmarks suggest this approach allows for rendering millions of simple sprites at playable framerates.14 Additionally, we will implement a Compute Shader culling pass, where the GPU determines which entities are within the camera frustum before passing them to the vertex shader, ensuring that off-screen entities consume almost no GPU resources.163. The Infinite Math Engine: Beyond 64 Bits3.1 The Limits of Floating PointStandard game engines use 32-bit (f32) or 64-bit (f64) floating-point numbers. While efficient, f64 has a hard limit at approximately $1.8 \times 10^{308}$. In a game inspired by the Balatro Cryptid mod, where multipliers can be exponential, players will quickly hit this "Infinity" cap, resulting in NaN (Not a Number) errors that crash the game logic.17 Furthermore, floating-point precision degrades as numbers get larger, making accurate comparisons impossible.3.2 The break_infinity ImplementationTo achieve true infinite scaling, Mugen-Kai will integrate a Rust port of the break_infinity.js library, a standard in the incremental game community. This library utilizes a custom struct, likely named BigDouble, which stores a mantissa (coefficient) and an exponent separately. This structure allows for numbers as large as $10^{(10^{15})}$, effectively removing any practical ceiling for damage or currency.18The BigDouble struct would look similar to this:Ruststruct BigDouble {
    mantissa: f64,
    exponent: i64,
}
Mathematical operations are overloaded for this struct. For example, multiplication involves multiplying the mantissas and adding the exponents: $(m_1 \times 10^{e_1}) \times (m_2 \times 10^{e_2}) = (m_1 \cdot m_2) \times 10^{(e_1 + e_2)}$. Addition is more complex, requiring normalization of the exponents. To optimize performance, the engine will check the difference between exponents. If $|e_1 - e_2| > 15$, the smaller number is insignificant relative to the larger one and can be ignored, saving distinct CPU cycles—a crucial optimization when summing damage from 10,000 projectiles.183.3 The "Cryptid" Scaling TiersThe defining feature of the Balatro Cryptid mod is not just big numbers, but the ability to change the formula of growth. Mugen-Kai implements a "Scaling Tier" system, where player abilities can upgrade the mathematical operator used for their damage calculation.5Tier 1: Linear & AdditiveThis is the standard RPG scaling.Formula: $Damage = Base + (Level \times 5)$Gameplay: Used for early game progression. Felt as steady but slow growth.Tier 2: MultiplicativeThe standard "crit" or "multiplier" scaling.Formula: $Damage = Base \times (1.5)^{Level}$Gameplay: The "hockey stick" curve begins.Tier 3: Exponential & TetrationThis is where Mugen-Kai breaks the mold. High-level "Jokers" (or equivalent artifacts) allow players to change the operator to exponentiation.Formula: $Damage = Base^{(1.01 \times Level)}$Advanced Formula (Tetration): $Damage = Base \uparrow\uparrow Level$ (iterated exponentiation).Technical Consideration: These calculations are computationally expensive. The engine will pre-calculate look-up tables (LUTs) for common exponential bases to avoid running pow() functions every frame.Tier 4: Recursive (The "Retrigger")Inspired by Balatro's "Retrigger" mechanic, this tier creates loops in the event queue. A "Recursive Strike" ability doesn't just deal damage; it triggers the "On Hit" event again. If the player has multiple "Retrigger" sources, this creates a feedback loop.20Safety Valve: To prevent infinite loops crashing the thread (Stack Overflow), the ECS EventWriter includes a depth counter. If an event retriggers itself more than MAX_DEPTH (e.g., 1,000 times), the loop is forcibly broken. This allows for "controlled infinity".214. The "Nen" Power System: Rule-Based Interactions4.1 From Stats to RulesStandard roguelikes rely on "Stat Checks" (Attack > Defense). The user request calls for an anime-inspired system like Hunter x Hunter's Nen, where interaction is governed by rules and compatibility.3 In Mugen-Kai, players do not choose a class; they cultivate an "Aura" that defines how their Entity interacts with the physics engine.4.2 The Six Aura ComponentsUsing the ECS, we implement the six Nen categories not as stats, but as logic modifiers.6Aura TypeECS Component LogicGameplay MechanicEnhancementModifier<T>Directly multiplies the values of other components. Simple but mathematically potent.TransmutationHitboxPropertiesChanges the physical properties of the aura. Can add Elastic (bounces enemies), Sticky (traps enemies), or Sharp (cuts geometry).EmissionChildEntityDetaches the hitbox from the player Transform. Allows remote hitboxes or "Nen Beasts" that operate independently.ConjurationSpawnEntityInstantiates physical objects with collision layers. Can create walls, traps, or weapons with unique Collider tags.ManipulationAIOverrideInjects a new Brain component into enemy entities. Can reprogram enemy targeting logic to attack other enemies.SpecializationSystemInjectionThe "Wildcard." Allows the player to inject custom logic into the game loop (e.g., "Steal enemy stats on hit").4.3 The "Vow and Restriction" SystemA key aspect of Nen is that power increases with risk (Vows). In game terms, this is a Contract System. Players can manually add "Debuff Components" to their entity to gain multipliers.7Example: A player might accept a MovementLock component (cannot move while attacking) in exchange for a 300% DamageMultiplier.Implementation: The DamageCalculationSystem checks for the existence of Restriction components. if entity.has(MovementLock) { damage *= 3.0; }. This encourages high-skill, high-risk builds.4.4 The "Parry" and Counter-Magic (Gyo/Ko)To satisfy the request for Jujutsu Kaisen-style counter-play, defensive mechanics must be active. We implement a "Perfect Parry" system inspired by Clair Obscur: Expedition 33.23Audio-Visual Telegraphs: Every enemy attack has a programmed "Wind-Up" phase. 200ms before the "Active Hitbox" phase, a specific audio cue plays.25The "Ko" State: Holding the block button concentrates aura (adding a Ko component to the hitbox). If an enemy attack collides with the player while the Ko component is active and within the first 10 frames of activation (Just Frame), it triggers a Counter Event.Rule Reflection: A counter does not just block damage. It reflects the Rule of the attack. If a "Curse" projectile is parried, the Curse component is stripped from the projectile and applied to the caster.26 This turns defense into a weapon.5. Combat AI: The Director and GOAP5.1 The Adaptive "Director" SystemRandom spawning creates uneven difficulty. To maintain the "Flow State," Mugen-Kai adopts the Director AI philosophy from Left 4 Dead.10 The Director is a high-level System that does not control individual units but manages the pacing of the simulation.5.1.1 Stress MetricsThe Director calculates a real-time Stress value for the player:$$Stress = (DamageTaken \times w_1) + (EnemyProximity \times w_2) + (ResourceStarvation \times w_3)$$Build-Up Phase: If Stress is low, the Director increases the spawn rate and introduces "Special" infected (Elite mobs).Peak Phase: When Stress approaches the threshold, the Director triggers a "Horde" event to force a climax.Relax Phase: Once the threshold is breached (or the Horde is defeated), the Director enters a cool-down state, despawning distant enemies and spawning Health/Currency to allow recovery.105.1.2 Reactive AdaptationUnlike L4D, Mugen-Kai's Director adapts to the player's stats, not just their performance.28Observer System: An ECS Observer tracks the type of damage the player deals.Scenario: The player is using a pure "Fire" build (Transmutation Aura).Response: The Director begins spawning enemies with the FireResist component.Escalation: If the player ignores this and scales Fire damage higher, the Director spawns enemies with FireAbsorb (healing from fire).Counter-Play: This forces the player to diversify their skill tree or utilize "Manipulation" abilities to control enemies, rather than relying on a single "broken" number.5.2 GOAP for Boss IntelligenceWhile hordes use simple steering behaviors (flocking), Bosses require intelligence. We utilize Goal-Oriented Action Planning (GOAP).29 A Boss Entity has a set of Actions (Charge, Summon, Heal) and a Goal (Kill Player).Planning: At the start of a decision cycle, the Boss simulates possible action sequences.Goal: Reduce Player HP to 0.Plan A: Charge (Requires line of sight).Plan B: Teleport -> Explosion (High cost).Execution: The Boss executes the plan. If the situation changes (e.g., player teleports away), the plan is invalidated, and a new plan is formulated. This creates dynamic, emergent behavior where bosses feel like they are actively trying to outsmart the player, rather than following a script.6. The Graph: Path of Exile-Style Progression6.1 The Skill Tree as a Data StructureThe request calls for the complexity of Path of Exile 2 skill trees. In Mugen-Kai, the skill tree is not a static menu; it is a massive Directed Graph represented in the ECS.31Nodes: 10,000+ nodes are generated. Each Node is an Entity with Position, Icon, and StatModifier components.Edges: Connections are defined by ConnectedTo components.Rendering: To render this massive tree without lag, we treat the UI exactly like the game world. We use the same Spatial Partitioning and GPU Instancing systems used for enemies to render the skill tree nodes. This allows for smooth zooming and panning over a galaxy of 10,000 stars (skills).166.2 Infinite Customization and JewelsThe graph supports "Jewel" sockets, which are entities that modify the tree itself.Radius Queries: When a Jewel is inserted, it performs a spatial query (using the SpatialGrid) to find all nodes within radius $R$.Logic Injection: A "Corruption Jewel" might iterate over the found nodes and mutate their StatModifier component. For example, it could flip all "Life Regeneration" nodes into "Life Degeneration (Self-Damage)" nodes in exchange for "Triple Damage."Dual Spec/Weapon Swap: Adopting Path of Exile 2’s weapon swap mechanics, the player can bind specific sections of the skill tree to specific weapon sets. When the player swaps weapons (e.g., from Sword to Wand), the ECS dynamically deactivates the "Melee" branch of the tree and activates the "Spell" branch instantly. This is handled by tagging tree nodes with WeaponSet(ID) components.317. The High-Stakes Economy: Loans and Debt7.1 The "Predatory" Game LoopIn most roguelikes, money is a reward. In Mugen-Kai, money is a shackle. This system draws on the mechanics of "predatory loans" and real-world debt traps to create tension.9The Initial Loan: The player starts with 0 Gold. To buy the starting gear, they must sign a contract with the "Iron Bank."Compound Interest: The debt grows in real-time. $Debt_{t} = Principal \times (1 + r)^t$. The interest rate $r$ is variable, tied to the Director's "Risk" metric. If the player is doing well, the Bank considers them "high risk" of paying off the loan too early and hikes the rate (predatory adjustment).The Repo Men: If the player's Debt exceeds their "Net Worth" (value of equipped items), the Director spawns "Repo Men." These are invincible entities that chase the player. If they touch the player, they don't deal damage; they unequip and steal items, effectively reducing the player's power mid-run.7.2 Inflation and Tiered CurrencyTo prevent hyper-inflation (common in MMOs and scaling games), we use a Tiered Currency system.34Copper (Tier 1): Dropped by standard mobs. Susceptible to massive inflation. Used for consumables.Silver (Tier 2): Dropped by Elites. Used for equipment repair and interest payments.Soul Notes (Tier 3 - Hard Currency): Only dropped by Bosses or acquired via "Gambling" wins. Used for permanent progression.The Exchange Rate: Players can exchange Copper for Silver, but the rate is dynamic based on the "Global Supply" of Copper in the current run. If the player has a "Gold Farming" build that generates millions of Copper, the exchange rate to Silver skyrockets (e.g., 1,000,000:1), devaluing their farming strategy. This mimics real-world hyperinflation scenarios.7.3 Gambling MechanicsThe "Shop" often features a Gambling Den. Players can wager their "Soul Notes" on stat rolls.The "Gacha" Stat System: Instead of buying +10 Strength, players buy a "Strength Lootbox." The distribution of outcomes follows a bell curve, but players can use "Loaded Dice" (consumables) to skew the probability. This leans into the Balatro vibe of manipulating RNG for profit.8. The Rune and Prophecy System: Risk as a Resource8.1 Real-Time Adaptation of Card MechanicsElder Scrolls Legends features a mechanic where losing health breaks "Runes," drawing cards that can be played instantly (Prophecy).36 Mugen-Kai adapts this turn-based mechanic into a real-time reactive system.8.2 The Rune ThresholdsThe player's Health Bar is visually segmented into 5 Runes.The Break Event: When damage pushes HP below a Rune segment, a RuneBreakEvent is broadcast in the ECS.The Prophecy Check: The system checks the player's "Deck" (a queue of pre-selected skills). The top skill is "drawn."Prophecy Hit: If the skill has the Prophecy tag, it triggers instantly and for free, interrupting the current animation.Prophecy Miss: If the skill lacks the tag, it is added to the player's "Hand" (cooldown buffer) but cannot be used immediately.Strategic Taking of Damage: This creates high-level play patterns. A player might see a massive boss attack winding up. Realizing they are out of resources, they might intentionally step into a small hazard to break a Rune, hoping to trigger a Prophecy: Time Freeze or Prophecy: Absolute Shield to counter the boss.8.3 Interaction with DebtThe Rune system interacts with the Economy via Insurance. Players can buy "Rune Insurance" from the Bank. If a Rune breaks and fails to trigger a Prophecy, the Bank pays out a lump sum of Gold. However, this increases the player's Debt Interest Rate. This interconnectivity ensures that every system (Health, Economy, Combat) feeds into the others.9. Implementation Roadmap9.1 Phase 1: The Foundation (Months 1-3)Core: Setup Rust/Bevy project structure.Math: Implement break_infinity crate and the custom Number component. Create the basic DamageSystem using these big integers.Physics: Implement the SpatialHash grid for collision detection. Benchmark with 100,000 static entities (Goal: 60 FPS).9.2 Phase 2: The Simulation (Months 4-6)ECS Logic: Implement the "Archetype vs. Sparse Set" storage optimization.Nen System: Create the 6 Aura components and the InteractionMatrix system (e.g., Fire + Oil = Explosion).Rendering: Implement WGPU Instancing and Compute Shader culling.9.3 Phase 3: The Brain (Months 7-9)AI: Build the Director System (Stress monitor) and the Spawner Logic.GOAP: Implement the Planner for a prototype Boss.Rune System: Implement the Health segmentation and Prophecy event queue.9.4 Phase 4: The Meta (Months 10-12)Economy: Implement the Debt calculator, Inflation logic, and Shop interface.Skill Tree: Build the Graph data structure and the "Zoomable" UI renderer.Balatro Mechanics: Implement the "Tier 4" Recursive Scaling and Event Loops.9.5 Phase 5: Polish & Juice (Months 13-15)Visuals: Add dynamic opacity, priority rendering for VFX.Audio: Implement the "Parry" audio cues.Optimization: Final profiling, SIMD optimizations for math, and threading tweaks.10. Conclusion: The Simulation of ExcessProject Mugen-Kai represents a paradigm shift in the roguelike genre. It moves away from the "illusion of scale" often found in Unity-based survivors (where enemies are pooled and capped) to a "reality of scale" enabled by Rust and Data-Oriented Design. By simulating 100,000+ entities with complex, rule-based interactions, and coupling this with a mathematical engine that supports infinite growth, Mugen-Kai offers the "broken," high-ceiling experience that modern players crave.The integration of a predatory economic meta-layer and a reactive Director AI ensures that this chaos remains engaging, pacing the experience to keep players in the zone between anxiety and boredom. This is a game designed to be broken by the player, and the architecture is built to withstand that breaking point without crashing. It is a simulation of excess, engineered for the infinite.